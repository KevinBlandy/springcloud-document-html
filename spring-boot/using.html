<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用Spring Boot - Spring中文文档</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Spring,SpringBoot,SpringCloud最新中文文档">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">Index</a></li><li class="chapter-item expanded "><a href="../spring-boot/index.html">Spring Boot</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spring-boot/getting-started.html">开始使用</a></li><li class="chapter-item "><a href="../spring-boot/upgrading.html">升级Spring Boot应用</a></li><li class="chapter-item expanded "><a href="../spring-boot/using.html" class="active">使用Spring Boot</a></li><li class="chapter-item "><a href="../spring-boot/features.html">Sring Boot特性</a></li><li class="chapter-item "><a href="../spring-boot/actuator.html">Spring Boot Actuator</a></li><li class="chapter-item "><a href="../spring-boot/cli.html">Spring Boot CLI</a></li><li class="chapter-item "><a href="../spring-boot/deployment.html">部署Spring Boot应用</a></li><li class="chapter-item "><a href="../spring-boot/build-tool-plugins.html">构建工具插件</a></li><li class="chapter-item "><a href="../spring-boot/howto.html">“How-to”指南</a></li><li class="chapter-item "><a href="../spring-boot/application-properties.html">Application Properties</a></li><li class="chapter-item "><a href="../spring-boot/configuration-metadata.html">Configuration Metadata</a></li><li class="chapter-item "><a href="../spring-boot/auto-configuration-classes.html">Auto-configuration classes</a></li><li class="chapter-item "><a href="../spring-boot/test-auto-configuration.html">Test auto-configuration annotations</a></li><li class="chapter-item "><a href="../spring-boot/executable-jar.html">可执行Jar</a></li><li class="chapter-item "><a href="../spring-boot/dependency-versions.html">依赖版本号</a></li></ol></li><li class="chapter-item "><a href="../spring-cloud/index.html">Spring Cloud</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spring-cloud/spring-cloud-azure.html">Spring Cloud Azure</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-alibaba.html">Spring Cloud Alibaba</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-for-amazon-web-services.html">Spring Cloud for Amazon Web Services</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-bus.html">Spring Cloud Bus</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-circuit-breaker.html">Spring Cloud Circuit Breaker</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-cli.html">Spring Cloud CLI</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-for-cloud-foundry.html">Spring Cloud for Cloud Foundry</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-cloud-foundry-service-nroker.html">Spring Cloud - Cloud Foundry Service Broker</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-cluster.html">Spring Cloud Cluster</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-commons.html">Spring Cloud Commons</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-config.html">Spring Cloud Config</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-cconnectors.html">Spring Cloud Connectors</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-consul.html">Spring Cloud Consul</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-contract.html">Spring Cloud Contract</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-function.html">Spring Cloud Function</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-gateway.html">Spring Cloud Gateway</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-gcp.html">Spring Cloud GCP</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-kubernetes.html">Spring Cloud Kubernetes</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-netflix].html">Spring Cloud Netflix</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-open-service-broker.html">Spring Cloud Open Service Broker</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-openfeign.html">Spring Cloud OpenFeign</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-pipelines.html">Spring Cloud Pipelines</a></li><li class="chapter-item "><a href="../spring-cloud-schema-registry.html">Spring Cloud Schema Registry</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-security.html">Spring Cloud Security</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-skipper.html">Spring Cloud Skipper</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth.html">Spring Cloud Sleuth</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/getting-started.html">入门使用</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/using.html">使用 Spring Cloud Sleuth</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/features.html">Spring Cloud Sleuth 特性</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/howto.html">“How-to” 指南</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/sleuth-integration.html">Spring Cloud Sleuth 整合</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-sleuth/appendix.html">附录</a></li></ol></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream.html">Spring Cloud Stream</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream/spring-cloud-stream-reference.html">Overview</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream/spring-cloud-stream-binder-rabbit.html">Rabbit MQ Binder</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream/spring-cloud-stream-binder-kafka.html">Apache Kafka Binder</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream/spring-cloud-stream-binder-kafka.html">Apache Kafka Streams Binder</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream/spring-cloud-stream-samples.html">Spring Cloud Stream Samples</a></li></ol></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream-app-starters.html">Spring Cloud Stream App Starters</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-stream-applications.html">Spring Cloud Stream Applications</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-task.html">Spring Cloud Task</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-task-app-starters.html">Spring Cloud Task App Starters</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-vault.html">Spring Cloud Vault</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-zookeeper.html">Spring Cloud Zookeeper</a></li><li class="chapter-item "><a href="../spring-cloud/spring-cloud-app-broker.html">Spring Cloud App Broker</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Spring中文文档</h1>

                    <div class="right-buttons">
                                                                                                <a href="https://github.com/KevinBlandy/springcloud-document/edit/master/src/spring-boot/using.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="使用springboot"><a class="header" href="#使用springboot">使用SpringBoot</a></h1>
<p>本节更详细地介绍了你应该如何使用Spring Boot。它涵盖了诸如构建系统、自动配置、以及如何运行你的应用程序等主题。我们还介绍了一些Spring Boot的最佳实践。虽然Spring Boot没有什么特别之处（它只是另一个你可以使用的库），但有一些建议，如果遵循这些建议，可以使你的开发过程更容易一些。</p>
<p>如果你开始使用Spring Boot，在进入本节之前，你可能应该先阅读<a href="/spring-boot/getting-started.html">入门</a>指南。</p>
<h2 id="1--构建系统"><a class="header" href="#1--构建系统">1.  构建系统</a></h2>
<p>强烈建议您选择一个支持<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.dependency-management"><em>依赖性管理</em></a>的构建系统，并且能够消费发布到 &quot;Maven Central&quot; 资源库的工件。我们建议你选择Maven或Gradle。让Spring Boot与其他构建系统（例如Ant）配合使用也是可能的，但它们的支持度不是特别高。</p>
<h3 id="11-依赖管理"><a class="header" href="#11-依赖管理">1.1. 依赖管理</a></h3>
<p>Spring Boot的每个版本都提供了一个它所支持的依赖关系的精选列表。在实践中，你不需要在构建配置中为这些依赖提供一个版本，因为Spring Boot会为你管理这些。当你升级Spring Boot本身时，这些依赖项也会以一致的方式被升级。</p>
<blockquote>
<p>你仍然可以指定一个版本，并在需要时覆盖Spring Boot的建议。</p>
</blockquote>
<blockquote>
<p>这个精心策划的列表包含了所有可以在Spring Boot中使用的Spring模块，以及第三方库的精炼列表。该列表以标准材料清单的形式提供（<code>spring-boot-dependencies</code>），可用于<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.maven">Maven</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.gradle">Gradle</a>。</p>
</blockquote>
<h3 id="12-maven"><a class="header" href="#12-maven">1.2. Maven</a></h3>
<p>要了解如何在Maven中使用Spring Boot，请参考Spring Boot的Maven插件的文档。</p>
<ul>
<li>Reference （<a href="https://docs.spring.io/spring-boot/docs/2.5.3/maven-plugin/reference/htmlsingle/">HTML</a>和<a href="https://docs.spring.io/spring-boot/docs/2.5.3/maven-plugin/reference/pdf/spring-boot-maven-plugin-reference.pdf">PDF</a>)</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.3/maven-plugin/api/">API</a></li>
</ul>
<h3 id="13-gradle"><a class="header" href="#13-gradle">1.3. Gradle</a></h3>
<p>要了解使用Spring Boot与Gradle的情况，请参考Spring Boot的Gradle插件的文档。</p>
<ul>
<li>Reference（<a href="https://docs.spring.io/spring-boot/docs/2.5.3/gradle-plugin/reference/htmlsingle/">HTML</a>和<a href="https://docs.spring.io/spring-boot/docs/2.5.3/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf">PDF</a>)</li>
<li><a href="https://docs.spring.io/spring-boot/docs/2.5.3/gradle-plugin/api/">API</a></li>
</ul>
<h3 id="14-ant"><a class="header" href="#14-ant">1.4. Ant</a></h3>
<p>可以使用Apache Ant+Ivy来构建Spring Boot项目。<code>spring-boot-antlib</code> &quot;AntLib&quot; 模块也可以用来帮助Ant创建可执行的jar。</p>
<p>为了声明依赖关系，一个典型的<code>ivy.xml</code>文件看起来像下面的例子。</p>
<pre><code class="language-xml">&lt;ivy-module version=&quot;2.0&quot;&gt;
    &lt;info organisation=&quot;org.springframework.boot&quot; module=&quot;spring-boot-sample-ant&quot; /&gt;
    &lt;configurations&gt;
        &lt;conf name=&quot;compile&quot; description=&quot;everything needed to compile this module&quot; /&gt;
        &lt;conf name=&quot;runtime&quot; extends=&quot;compile&quot; description=&quot;everything needed to run this module&quot; /&gt;
    &lt;/configurations&gt;
    &lt;dependencies&gt;
        &lt;dependency org=&quot;org.springframework.boot&quot; name=&quot;spring-boot-starter&quot;
            rev=&quot;${spring-boot.version}&quot; conf=&quot;compile&quot; /&gt;
    &lt;/dependencies&gt;
&lt;/ivy-module&gt;
</code></pre>
<p>一个典型的<code>build.xml</code>看起来像下面的例子。</p>
<pre><code class="language-xml">&lt;project
    xmlns:ivy=&quot;antlib:org.apache.ivy.ant&quot;
    xmlns:spring-boot=&quot;antlib:org.springframework.boot.ant&quot;
    name=&quot;myapp&quot; default=&quot;build&quot;&gt;

    &lt;property name=&quot;spring-boot.version&quot; value=&quot;2.5.3&quot; /&gt;

    &lt;target name=&quot;resolve&quot; description=&quot;--&gt; retrieve dependencies with ivy&quot;&gt;
        &lt;ivy:retrieve pattern=&quot;lib/[conf]/[artifact]-[type]-[revision].[ext]&quot; /&gt;
    &lt;/target&gt;

    &lt;target name=&quot;classpaths&quot; depends=&quot;resolve&quot;&gt;
        &lt;path id=&quot;compile.classpath&quot;&gt;
            &lt;fileset dir=&quot;lib/compile&quot; includes=&quot;*.jar&quot; /&gt;
        &lt;/path&gt;
    &lt;/target&gt;

    &lt;target name=&quot;init&quot; depends=&quot;classpaths&quot;&gt;
        &lt;mkdir dir=&quot;build/classes&quot; /&gt;
    &lt;/target&gt;

    &lt;target name=&quot;compile&quot; depends=&quot;init&quot; description=&quot;compile&quot;&gt;
        &lt;javac srcdir=&quot;src/main/java&quot; destdir=&quot;build/classes&quot; classpathref=&quot;compile.classpath&quot; /&gt;
    &lt;/target&gt;

    &lt;target name=&quot;build&quot; depends=&quot;compile&quot;&gt;
        &lt;spring-boot:exejar destfile=&quot;build/myapp.jar&quot; classes=&quot;build/classes&quot;&gt;
            &lt;spring-boot:lib&gt;
                &lt;fileset dir=&quot;lib/runtime&quot; /&gt;
            &lt;/spring-boot:lib&gt;
        &lt;/spring-boot:exejar&gt;
    &lt;/target&gt;
&lt;/project&gt;

</code></pre>
<p>如果你不想使用<code>spring-boot-antlib</code>模块，请参阅<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.build.build-an-executable-archive-with-ant-without-using-spring-boot-antlib">howto.html</a> “How-to”。</p>
<h3 id="15-starters"><a class="header" href="#15-starters">1.5. Starters</a></h3>
<p>Starters是一组方便的依赖描述符，你可以在你的应用程序中包含它们。你可以获得所有你需要的Spring和相关技术的一站式服务，而不需要在样本代码中寻找和复制粘贴大量的dependency。例如，如果你想开始使用Spring和JPA进行数据库访问，在你的项目中包括<code>spring-boot-starter-data-jpa</code>依赖项。</p>
<p>starter包含了很多你需要的依赖，以使项目快速启动和运行，并拥有一套一致的、受支持的可管理的过渡性依赖。</p>
<blockquote>
<p>名字里有什么</p>
<p>所有<strong>官方的</strong>starter都遵循一个类似的命名模式：<code>spring-boot-starter-*</code>，其中<code>*</code>是一个特定的应用程序类型。这种命名结构是为了帮助你找到starter。许多IDE中的Maven集成可以让你按名称搜索依赖关系。例如，如果安装了相应的Eclipse或Spring Tools插件，你可以在POM编辑器中按下<code>ctrl-space</code>，然后输入 &quot;spring-boot-starter&quot;，就能得到完整的列表。</p>
<p>正如&quot;<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration.custom-starter">创建你自己的starter</a> &quot;一节所解释的，第三方starter不应该以<code>spring-boot</code>开头，因为它是为官方Spring Boot工件保留的。相反，第三方starter通常以项目的名称开始。例如，一个名为<code>thirdpartyproject</code>的第三方starter项目通常被命名为<code>thirdpartyproject-spring-boot-starter</code>。</p>
</blockquote>
<p><strong>以下是Spring Boot在<code>org.springframework.boot</code> group下提供的application starters。</strong></p>
<p>表1. Spring Boot application starters</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spring-boot-starter</code></td><td>核心starter，包括自动配置支持、日志和YAML</td></tr>
<tr><td><code>spring-boot-starter-activemq</code></td><td>使用Apache ActiveMQ的JMS消息传递的Starter</td></tr>
<tr><td><code>spring-boot-starter-amqp</code></td><td>使用Spring AMQP和Rabbit MQ的Starter</td></tr>
<tr><td><code>spring-boot-starter-aop</code></td><td>使用Spring AOP和AspectJ进行面向切面的编程的Starter</td></tr>
<tr><td><code>spring-boot-starter-artemis</code></td><td>使用Apache Artemis的JMS消息传递的starter</td></tr>
<tr><td><code>spring-boot-starter-batch</code></td><td>使用Spring Batch的starter</td></tr>
<tr><td><code>spring-boot-starter-cache</code></td><td>使用Spring框架的缓存支持的starter</td></tr>
<tr><td><code>spring-boot-starter-data-cassandra</code></td><td>使用Cassandra分布式数据库和Spring Data Cassandra的starter</td></tr>
<tr><td><code>spring-boot-starter-data-cassandra-reactive</code></td><td>使用Cassandra分布式数据库和Spring Data Cassandra Reactive的starter</td></tr>
<tr><td><code>spring-boot-starter-data-couchbase</code></td><td>使用Couchbase面向文档的数据库和Spring Data Couchbase的starter</td></tr>
<tr><td><code>spring-boot-starter-data-couchbase-reactive</code></td><td>使用Couchbase面向文档的数据库和Spring Data Couchbase Reactive的starter</td></tr>
<tr><td><code>spring-boot-starter-data-elasticsearch</code></td><td>使用Elasticsearch搜索和分析引擎以及Spring Data Elasticsearch的starter</td></tr>
<tr><td><code>spring-boot-starter-data-jdbc</code></td><td>使用Spring Data JDBC的starter</td></tr>
<tr><td><code>spring-boot-starter-data-jpa</code></td><td>使用Spring Data JPA与Hibernate的starter</td></tr>
<tr><td><code>spring-boot-starter-data-ldap</code></td><td>使用Spring Data LDAP的starter</td></tr>
<tr><td><code>spring-boot-starter-data-mongodb</code></td><td>使用MongoDB面向文档的数据库和Spring Data MongoDB的starter</td></tr>
<tr><td><code>spring-boot-starter-data-mongodb-reactive</code></td><td>使用MongoDB面向文档的数据库和Spring Data MongoDB Reactive的starter</td></tr>
<tr><td><code>spring-boot-starter-data-neo4j</code></td><td>使用Neo4j图形数据库和Spring Data Neo4j的starter</td></tr>
<tr><td><code>spring-boot-starter-data-r2dbc</code></td><td>使用Spring Data R2DBC的starter</td></tr>
<tr><td><code>spring-boot-starter-data-redis</code></td><td>用Spring Data Redis和Lettuce客户端使用Redis键值数据存储的starter</td></tr>
<tr><td><code>spring-boot-starter-data-redis-reactive</code></td><td>使用Redis键值数据存储与Spring Data Redis Reactive和Lettuce客户端的starter</td></tr>
<tr><td><code>spring-boot-starter-data-rest</code></td><td>使用Spring Data REST通过REST暴露Spring Data存储库的starter</td></tr>
<tr><td><code>spring-boot-starter-freemarker</code></td><td>使用FreeMarker视图构建MVC网络应用程序的starter</td></tr>
<tr><td><code>spring-boot-starter-groovy-templates</code></td><td>使用Groovy模板视图构建MVC网络应用的starter</td></tr>
<tr><td><code>spring-boot-starter-hateoas</code></td><td>使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful网络应用程序的starter</td></tr>
<tr><td><code>spring-boot-starter-integration</code></td><td>使用Spring集成的starter</td></tr>
<tr><td><code>spring-boot-starter-jdbc</code></td><td>使用JDBC与HikariCP连接池的starter</td></tr>
<tr><td><code>spring-boot-starter-jersey</code></td><td>使用JAX-RS和Jersey构建RESTful网络应用的入门级软件。是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>的替代品。</td></tr>
<tr><td><code>spring-boot-starter-jooq</code></td><td>使用jOOQ访问SQL数据库的starter。是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-data-jpa"><code>spring-boot-starter-data-jpa</code></a>或<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-jdbc"><code>spring-boot-starter-jdbc</code></a>的替代品。</td></tr>
<tr><td><code>spring-boot-starter-json</code></td><td>读取和写入json的starter</td></tr>
<tr><td><code>spring-boot-starter-jta-atomikos</code></td><td>使用Atomikos的JTA事务的starter</td></tr>
<tr><td><code>spring-boot-starter-mail</code></td><td>使用Java Mail和Spring Framework的电子邮件发送支持的starter</td></tr>
<tr><td><code>spring-boot-starter-mustache</code></td><td>使用Mustache视图构建网络应用的starter</td></tr>
<tr><td><code>spring-boot-starter-oauth2-client</code></td><td>使用Spring Security的OAuth2/OpenID连接客户端功能的starter</td></tr>
<tr><td><code>spring-boot-starter-oauth2-resource-server</code></td><td>使用Spring Security的OAuth2资源服务器功能的starter</td></tr>
<tr><td><code>spring-boot-starter-quartz</code></td><td>使用Quartz调度器的starter</td></tr>
<tr><td><code>spring-boot-starter-rsocket</code></td><td>构建RSocket客户端和服务器的starter</td></tr>
<tr><td><code>spring-boot-starter-security</code></td><td>使用Spring Security的starter</td></tr>
<tr><td><code>spring-boot-starter-test</code></td><td>使用包括JUnit Jupiter、Hamcrest和Mockito在内的库来测试Spring Boot应用的入门者</td></tr>
<tr><td><code>spring-boot-starter-thymeleaf</code></td><td>使用Thymeleaf视图构建MVC网络应用的starter</td></tr>
<tr><td><code>spring-boot-starter-validation</code></td><td>使用Hibernate验证器的Java Bean验证的starter</td></tr>
<tr><td><code>spring-boot-starter-web</code></td><td>使用Spring MVC构建Web（包括RESTful）应用程序的starter。使用Tomcat作为默认的嵌入式容器</td></tr>
<tr><td><code>spring-boot-starter-web-services</code></td><td>使用Spring Web services的starter</td></tr>
<tr><td><code>spring-boot-starter-webflux</code></td><td>使用Spring框架的Reactive Web支持构建WebFlux应用程序的starter</td></tr>
<tr><td><code>spring-boot-starter-websocket</code></td><td>使用Spring框架的WebSocket支持构建WebSocket应用的starter</td></tr>
</tbody></table>
<p><strong>除了pplication starters，以下starter可用于添加<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator">production ready</a>功能。</strong></p>
<p>表 2. Spring Boot production starters</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spring-boot-starter-actuator</code></td><td>使用Spring Boot的Actuator的starter，它提供了生产准备的功能，帮助你监控和管理你的应用程序。</td></tr>
</tbody></table>
<p><strong>最后，Spring Boot还包括以下starter，如果你想排除或调换特定的实现，可以使用。</strong></p>
<p>表 3. Spring Boot technical starters</p>
<table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>spring-boot-starter-jetty</code></td><td>使用Jetty作为嵌入式servlet容器的starter。是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品。</td></tr>
<tr><td><code>spring-boot-starter-log4j2</code></td><td>使用Log4j2进行日志记录的starter。是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-logging"><code>spring-boot-starter-logging</code></a>的替代品。</td></tr>
<tr><td><code>spring-boot-starter-logging</code></td><td>使用Logback进行日志记录的starter。默认的日志starter</td></tr>
<tr><td><code>spring-boot-starter-reactor-netty</code></td><td>使用Reactor Netty作为嵌入式Reactor HTTP服务器的starter。</td></tr>
<tr><td><code>spring-boot-starter-tomcat</code></td><td>使用Tomcat作为嵌入式servlet容器的starter。默认的servlet容器starter由<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-web"><code>spring-boot-starter-web</code></a>使用。</td></tr>
<tr><td><code>spring-boot-starter-undertow</code></td><td>使用Undertow作为嵌入式Servlet容器的starter。是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#spring-boot-starter-tomcat"><code>spring-boot-starter-tomcat</code></a>的替代品。</td></tr>
</tbody></table>
<p>如果需要更换实现，请看<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.webserver.use-another">更换服务器</a>和<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.logging.log4j">日志系统</a>的操作文档。</p>
<blockquote>
<p>关于其他社区贡献的启动器列表，请参见GitHub上<code>spring-boot-starters</code>模块的<a href="https://github.com/spring-projects/spring-boot/tree/main/spring-boot-project/spring-boot-starters/README.adoc">README文件</a>。</p>
</blockquote>
<h2 id="2-构建你的代码"><a class="header" href="#2-构建你的代码">2. 构建你的代码</a></h2>
<p>Spring Boot并不要求任何特定的代码布局来工作。但是，有一些最佳实践可以帮助。</p>
<h3 id="21-使用e-default-package"><a class="header" href="#21-使用e-default-package">2.1. 使用e “default package”</a></h3>
<p>当一个类不包括 <code>package</code> 的声明时，它被认为是在 <code>default package</code> 中。通常不鼓励使用 <code>default package</code>，应避免使用。对于使用<code>@ComponentScan</code>、<code>@ConfigurationPropertiesScan</code>、<code>@EntityScan</code>或<code>@SpringBootApplication</code> 注解的Spring Boot应用程序，它可能会造成特别的问题，因为每个jar中的每个类都会被读取。</p>
<blockquote>
<p>我们建议你遵循Java推荐的包的命名惯例，并使用反转的域名（例如，<code>com.example.project</code>）。</p>
</blockquote>
<h3 id="22-main方法类"><a class="header" href="#22-main方法类">2.2. Main方法类</a></h3>
<p>我们通常建议你将你的Main方法类放在根包中，高于其他类。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.using-the-springbootapplication-annotation"><code>@SpringBootApplication</code>注解</a>经常被放在你的Main类上，它隐含地定义了某些项目的基础 &quot;搜索包&quot;。例如，如果你正在编写一个JPA应用程序，<code>@SpringBootApplication</code>注解类的包被用来搜索<code>@Entity</code>项目。使用一个根包也允许组件扫描只适用于你的项目。</p>
<blockquote>
<p>如果你不想使用<code>@SpringBootApplication</code>，它所导入的<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>注解定义了该行为，所以你也可以使用这些来代替。</p>
</blockquote>
<p>下面列出了一个典型的布局。</p>
<pre><code class="language-text">com
 +- example
     +- myapplication
         +- MyApplication.java
         |
         +- customer
         |   +- Customer.java
         |   +- CustomerController.java
         |   +- CustomerService.java
         |   +- CustomerRepository.java
         |
         +- order
             +- Order.java
             +- OrderController.java
             +- OrderService.java
             +- OrderRepository.java
</code></pre>
<p><code>MyApplication.java</code>文件将声明<code>main</code>方法，以及基本的<code>@SpringBootApplication</code>，如下所示。</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

}
</code></pre>
<h2 id="3-configuration-类"><a class="header" href="#3-configuration-类">3. Configuration 类</a></h2>
<p>Spring Boot倾向于基于Java的配置。虽然可以使用XML源的<code>SpringApplication</code>，但我们一般建议你的主要源是一个<code>@Configuration</code>类。通常，定义<code>main</code>方法的类是作为主要<code>@Configuration</code>的良好候选者。</p>
<blockquote>
<p>互联网上已经发布了许多使用XML配置的Spring配置实例。如果可能的话，总是尝试使用基于Java的同等配置。搜索<code>Enable*</code>注解可以是一个很好的起点。</p>
</blockquote>
<h3 id="31-导入额外的-configuration-类"><a class="header" href="#31-导入额外的-configuration-类">3.1. 导入额外的 Configuration 类</a></h3>
<p>你不需要把所有的<code>@Configuration</code>放在一个单一的类中。<code>@Import</code>注解可以用来导入额外的配置类。另外，你可以使用<code>@ComponentScan</code>来自动拾取所有Spring组件，包括<code>@Configuration</code>类。</p>
<h3 id="32-导入-xml-configuration"><a class="header" href="#32-导入-xml-configuration">3.2. 导入 XML Configuration</a></h3>
<p>如果你绝对必须使用基于XML的配置，我们建议你仍然从<code>@Configuration</code>类开始。然后你可以使用<code>@ImportResource</code>注解来加载XML配置文件。</p>
<h2 id="4-auto-configuration"><a class="header" href="#4-auto-configuration">4. Auto-configuration</a></h2>
<p>Spring Boot自动配置试图根据你所添加的jar依赖项自动配置你的Spring应用程序。例如，如果<code>HSQLDB</code>在你的classpath上，而且你没有手动配置任何数据库连接Bean，那么Spring Boot就会自动配置内存数据库。</p>
<p>你需要将<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>注解添加到你的<code>@Configuration</code>类中，从而选择加入自动配置。</p>
<blockquote>
<p>你应该只添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>注解。我们通常建议你只在你的主<code>@Configuration</code>类中添加一个或另一个。</p>
</blockquote>
<h3 id="41-逐步替换-auto-configuration"><a class="header" href="#41-逐步替换-auto-configuration">4.1. 逐步替换 Auto-configuration</a></h3>
<p>自动配置是非侵入性的。在任何时候，你都可以开始定义你自己的配置来替换自动配置的特定部分。例如，如果你添加了你自己的<code>DataSource</code>bean，默认的嵌入式数据库支持就会退缩。</p>
<p>如果你需要找出当前正在应用的自动配置，以及为什么，用<code>--debug</code>开关启动你的应用程序。这样做可以为选定的核心记录器启用调试日志，并将条件报告记录到控制台。</p>
<h3 id="42-42-禁用指定的-auto-configuration-类"><a class="header" href="#42-42-禁用指定的-auto-configuration-类">4.2. 4.2. 禁用指定的 Auto-configuration 类</a></h3>
<p>如果你发现你不想要的特定自动配置类被应用，你可以使用<code>@SpringBootApplication</code>的<code>exclude</code>属性来禁用它们，如下例所示。</p>
<pre><code class="language-java">@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })
public class MyApplication {

}
</code></pre>
<p>如果该类不在classpath上，你可以使用注解的<code>excludeName</code>属性并指定完全合格的名称来代替。如果你喜欢使用<code>@EnableAutoConfiguration</code>而不是<code>@SpringBootApplication</code>，<code>exclude</code>和<code>excludeName</code>也可用。最后，你也可以通过使用<code>spring.autoconfigure.exclude</code>属性来控制要排除的自动配置类列表。</p>
<blockquote>
<p>注解 + 配置的方式可以一起使用</p>
</blockquote>
<blockquote>
<p>即使自动配置类是 <code>public</code> 的，唯一被认为是公共API的方面是该类的名称，它可以用于禁用自动配置。这些类的实际内容，如嵌套的配置类或Bean方法，只供内部使用，我们不建议直接使用这些。</p>
</blockquote>
<h2 id="5-spring-bean-依赖和注入"><a class="header" href="#5-spring-bean-依赖和注入">5. Spring Bean 依赖和注入</a></h2>
<p>你可以自由地使用任何标准的Spring框架技术来定义你的Bean及其注入的依赖关系。我们通常推荐使用构造函数注入来连接依赖关系，并使用<code>@ComponentScan</code>来查找Bean。</p>
<p>如果你按照上面的建议构造你的代码（将你的应用类定位在顶级包中），你可以添加<code>@ComponentScan</code>而不需要任何参数，或者使用<code>@SpringBootApplication</code>注解来隐含地包含它。你所有的应用组件（<code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>等）都会自动注册为Spring Bean。</p>
<p>下面的例子显示了一个<code>@Service</code>Bean，它使用构造函数注入来获得一个所需的<code>RiskAssessor</code>Bean。</p>
<pre><code class="language-java">import org.springframework.stereotype.Service;

@Service
public class MyAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public MyAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }

    // ...

}
</code></pre>
<p>如果一个Bean有多个构造函数，你需要用<code>@Autowired</code>来标记你希望Spring使用的那个。</p>
<pre><code class="language-java">import java.io.PrintStream;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class MyAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    private final PrintStream out;

    @Autowired
    public MyAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
        this.out = System.out;
    }

    public MyAccountService(RiskAssessor riskAssessor, PrintStream out) {
        this.riskAssessor = riskAssessor;
        this.out = out;
    }

    // ...

}
</code></pre>
<blockquote>
<p>请注意，使用构造器注入让<code>riskAssessor</code>字段被标记为<code>final</code>，表明它随后不能被改变。</p>
</blockquote>
<h2 id="6-使用-springbootapplication-注解"><a class="header" href="#6-使用-springbootapplication-注解">6. 使用 @SpringBootApplication 注解</a></h2>
<p>许多Spring Boot开发者希望他们的应用程序能够使用自动配置、组件扫描，并且能够在他们的 &quot;application class&quot; 上定义额外的配置。一个<code>@SpringBootApplication</code>注解就可以用来启用这三个功能，也就是。</p>
<ul>
<li><code>@EnableAutoConfiguration</code> ：启用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.auto-configuration">Spring Boot的自动配置机制</a></li>
<li><code>@ComponentScan</code> : 在应用程序所在的包上启用<code>@Component</code>扫描（参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.structuring-your-code">最佳实践</a>)</li>
<li><code>@SpringBootConfiguration</code>：启用在上下文中注册额外的Bean或导入额外的配置类。这是Spring标准<code>@Configuration</code>的替代方案，有助于在你的集成测试中进行<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.detecting-configuration">配置检测</a>。</li>
</ul>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @SpringBootConfiguration @EnableAutoConfiguration
                        // @ComponentScan
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

}
</code></pre>
<blockquote>
<p><code>@SpringBootApplication</code>也提供了别名来定制<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的属性。</p>
</blockquote>
<p>这些功能都不是强制性的，你可以选择用它所启用的任何功能来代替这个单一的注解。例如，你可能不希望在你的应用程序中使用组件扫描或配置属性扫描。</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Import;

@SpringBootConfiguration(proxyBeanMethods = false)
@EnableAutoConfiguration
@Import({ SomeConfiguration.class, AnotherConfiguration.class })
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

}
</code></pre>
<blockquote>
<p>在这个例子中，<code>MyApplication</code>和其他Spring Boot应用程序一样，只是<code>@Component</code>-注解的类和<code>@ConfigurationProperties</code>-注解的类没有被自动检测到，用户定义的Bean被明确导入（见<code>@Import</code>）。</p>
</blockquote>
<h2 id="7-运行你的应用程序"><a class="header" href="#7-运行你的应用程序">7. 运行你的应用程序</a></h2>
<p>将你的应用程序打包成jar并使用嵌入式HTTP服务器的最大优势之一是，你可以像其他应用程序一样运行你的应用程序。该样本适用于调试Spring Boot应用程序。你不需要任何特殊的IDE插件或扩展。</p>
<blockquote>
<p>本节只涉及基于jar的打包。如果你选择将你的应用程序打包成war文件，你应该参考你的服务器和IDE文档。</p>
</blockquote>
<h3 id="71-在-ide-中运行"><a class="header" href="#71-在-ide-中运行">7.1. 在 IDE 中运行</a></h3>
<p>你可以从你的IDE中把Spring Boot应用作为一个Java应用运行。不过，你首先需要导入你的项目。导入步骤因你的IDE和构建系统而异。大多数IDE可以直接导入Maven项目。例如，Eclipse用户可以从<code>File</code>菜单中选择<code>Import...</code>→<code>Existing Maven Projects</code>。</p>
<p>如果你不能直接将项目导入IDE，你可以通过使用构建插件来生成IDE元数据。Maven包括用于<a href="https://maven.apache.org/plugins/maven-eclipse-plugin/">Eclipse</a>和<a href="https://maven.apache.org/plugins/maven-idea-plugin/">IDEA</a>的插件。Gradle为<a href="https://docs.gradle.org/current/userguide/userguide.html">各种IDE</a>提供插件。</p>
<blockquote>
<p>如果你不小心运行了两次web application，你会看到一个 &quot;Port already in use&quot;的错误。Spring Tools用户可以使用<code>Relaunch</code>按钮而不是<code>Run</code>按钮来确保任何现有的实例被关闭。</p>
</blockquote>
<h3 id="72-以打包的方式运行的应用程序"><a class="header" href="#72-以打包的方式运行的应用程序">7.2. 以打包的方式运行的应用程序</a></h3>
<p>如果你使用Spring Boot的Maven或Gradle插件来创建一个可执行的jar，你可以使用<code>java -jar</code>来运行你的应用程序，如下例所示。</p>
<pre><code class="language-shell">$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar
</code></pre>
<p>也可以在启用远程调试支持的情况下运行一个打包的应用程序。这样做可以让你把调试器附加到你的打包的应用程序上，如下面的例子中所示。</p>
<pre><code class="language-shell">$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \
       -jar target/myapplication-0.0.1-SNAPSHOT.jar

</code></pre>
<h3 id="73-使用maven插件"><a class="header" href="#73-使用maven插件">7.3. 使用Maven插件</a></h3>
<p>Spring Boot Maven插件包括一个<code>run</code>目标，可用于快速编译和运行您的应用程序。应用程序以爆炸的形式运行，就像在IDE中一样。下面的例子显示了运行Spring Boot应用程序的典型Maven命令。</p>
<pre><code class="language-shell">$ mvn spring-boot:run
</code></pre>
<p>你可能还想使用<code>MAVEN_OPTS</code>操作系统环境变量，如下例所示。</p>
<pre><code class="language-shell">$ export MAVEN_OPTS=-Xmx1024m
</code></pre>
<h3 id="74-使用gradle插件"><a class="header" href="#74-使用gradle插件">7.4. 使用Gradle插件</a></h3>
<p>Spring Boot Gradle插件还包括一个<code>bootRun</code>任务，可以用来以爆炸的形式运行你的应用程序。只要你应用<code>org.springframework.boot</code>和<code>java</code>插件，就会添加<code>bootRun</code>任务，如下例所示。</p>
<pre><code class="language-shell">$ gradle bootRun
</code></pre>
<p>你可能还想使用<code>JAVA_OPTS</code>操作系统环境变量，如下例所示。</p>
<pre><code class="language-shell">$ export JAVA_OPTS=-Xmx1024m
</code></pre>
<h3 id="75-热部署"><a class="header" href="#75-热部署">7.5. 热部署</a></h3>
<p>由于Spring Boot应用程序是普通的Java应用程序，JVM热部署应该可以开箱即用。JVM热部署所能替换的字节码有一定的限制。要获得更完整的解决方案，可以使用<a href="https://www.jrebel.com/products/jrebel">JRebel</a>。</p>
<blockquote>
<p><code>spring-boot-devtools</code>模块还包括对快速重启应用程序的支持。详情请见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.hotswapping">Hot swapping &quot;How-to&quot;</a>。</p>
</blockquote>
<h2 id="8-developer-tools"><a class="header" href="#8-developer-tools">8. Developer Tools</a></h2>
<p>Spring Boot包括一套额外的工具，可以使应用程序开发的体验更加愉快。<code>spring-boot-devtools</code>模块可以包含在任何项目中，以提供额外的开发时间功能。要包含devtools支持，请将模块依赖性添加到你的构建中，如下面Maven和Gradle的列表中所示。</p>
<p>Maven</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>Gradle</p>
<pre><code class="language-groovy">dependencies {
    developmentOnly(&quot;org.springframework.boot:spring-boot-devtools&quot;)
}
</code></pre>
<blockquote>
<p>当运行一个完全打包的应用程序时，开发者工具会被自动禁用。如果你的应用程序是从<code>java -jar</code>启动的，或者是从一个特殊的classloader启动的，那么它就被认为是一个 <code>production application</code>。你可以通过使用<code>spring.devtools.restart.enabled</code>系统属性来控制这一行为。要启用devtools，无论使用何种类加载器来启动你的应用程序，设置<code>-Dspring.devtools.restart.enabled=true</code>系统属性。在生产环境中不能这样做，因为运行devtools会有安全风险。要禁用devtools，请排除该依赖关系或设置<code>-Dspring.devtools.restart.enabled=false</code>系统属性。</p>
</blockquote>
<blockquote>
<p>在Maven中把该依赖标记为可选，或在Gradle中使用 <code>developmentOnly</code> 配置（如上所示），可以防止devtools被过渡应用到使用你的项目的其他模块。</p>
</blockquote>
<blockquote>
<p>重新打包的归档文件默认不包含devtools。如果你想使用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.remote-applications">某个远程devtools功能</a>，你需要包含它。使用Maven插件时，将<code>excludeDevtools</code>属性设置为<code>false</code>。使用Gradle插件时，<a href="https://docs.spring.io/spring-boot/docs/2.5.3/gradle-plugin/reference/htmlsingle/#packaging-executable-configuring-including-development-only-dependencies">配置任务的classpath以包括<code>developmentOnly</code>配置</a>。</p>
</blockquote>
<h3 id="81-默认属性值"><a class="header" href="#81-默认属性值">8.1. 默认属性值</a></h3>
<p>Spring Boot支持的几个库使用缓存来提高性能。例如，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-web-applications.spring-mvc.template-engines">模板引擎</a>对编译的模板进行缓存，以避免重复解析模板文件。另外，Spring MVC在提供静态资源时可以在响应中添加HTTP缓存头。</p>
<p>虽然缓存在生产中非常有利，但在开发过程中可能会产生反作用，使你无法看到你刚刚在应用中的变化。由于这个原因，spring-boot-devtools默认禁用了缓存选项。</p>
<p>缓存选项通常由你的<code>application.properties</code>文件中的设置来配置。例如，Thymeleaf提供了<code>spring.thymeleaf.cache</code>属性。与其需要手动设置这些属性，<code>spring-boot-devtools</code>模块会自动应用合理的开发时配置。</p>
<p>因为你在开发Spring MVC和Spring WebFlux应用程序时需要更多关于Web请求的信息，开发者工具将为<code>web</code>日志组启用<code>DEBUG</code>日志。这将给你提供关于传入请求的信息，哪个处理程序正在处理它，响应结果等。如果你希望记录所有的请求细节（包括潜在的敏感信息），你可以打开<code>spring.mvc.log-request-details</code>或<code>spring.codec.log-request-details</code>配置属性。</p>
<blockquote>
<p>如果你不希望应用属性默认值，你可以在你的<code>application.properties</code>中设置<code>spring.devtools.add-perties</code>为<code>false</code>。</p>
</blockquote>
<blockquote>
<p>关于devtools应用的属性的完整列表，见<a href="https://github.com/spring-projects/spring-boot/tree/v2.5.3/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java">DevToolsPropertyDefaultsPostProcessor</a>。</p>
</blockquote>
<h3 id="82-自动重启"><a class="header" href="#82-自动重启">8.2. 自动重启</a></h3>
<p>使用<code>spring-boot-devtools</code>的应用程序在classpath上的文件发生变化时自动重新启动。当在IDE中工作时，这可能是一个有用的功能，因为它为代码变化提供了一个非常快速的反馈回路。默认情况下，classpath上任何指向目录的条目都会被监测到变化。注意，某些资源，如静态资源和视图模板，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart.excluding-resources">不需要重新启动应用程序</a>。</p>
<p>触发重启</p>
<ul>
<li>由于DevTools监控classpath资源，触发重启的唯一方法是更新classpath。导致classpath被更新的方式取决于你所使用的IDE。</li>
<li>在Eclipse中，保存一个修改过的文件会导致classpath被更新并触发重启。</li>
<li>在IntelliJ IDEA中，构建项目（<code>Build +→+ Build Project</code>）有同样的效果。</li>
<li>如果使用构建插件，运行Maven的<code>mvn compile</code>或Gradle的<code>gradle build</code>将触发重启。</li>
</ul>
<p>如果你使用Maven或Gradle的构建插件进行重启，你必须将<code>forking</code>设置为<code>enabled</code>。如果你禁用forking，devtools使用的隔离应用程序classloader将不会被创建，重新启动将无法正常运行。</p>
<p>自动重启与LiveReload一起使用时效果非常好。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.livereload">详见LiveReload部分</a>。如果你使用JRebel，自动重启被禁用，而采用动态类重载。其他devtools的功能（如LiveReload和属性覆盖）仍然可以使用。</p>
<p>DevTools依靠应用程序上下文的shutdown hook来在重启期间关闭它。如果你禁用了shutdown hook（<code>SpringApplication.setRegisterShutdownHook(false)</code>），它就不能正确工作。</p>
<p>DevTools需要定制<code>ApplicationContext</code>所使用的<code>ResourceLoader</code>。如果你的应用程序已经提供了一个，它将被包装。不支持直接覆盖<code>ApplicationContext</code>上的<code>getResource</code>方法。</p>
<p>重启与重新加载</p>
<p>Spring Boot提供的重启技术通过使用两个类加载器来工作。不变的类（例如，来自第三方jars的类）被加载到<em>base</em>类加载器。你正在开发的类被加载到<em>restart</em>类加载器中。当应用程序被重新启动时，<em>restart</em>类加载器被扔掉，并创建一个新的。这种方法意味着应用程序的重启通常比 &quot;冷启动 &quot;快得多，因为<em>基</em>类加载器已经可用并被填充。</p>
<p>如果你发现重启对你的应用程序来说不够快，或者你遇到了类加载问题，你可以考虑ZeroTurnaround的<a href="https://jrebel.com/software/jrebel/">JRebel</a>等重载技术。这些技术的工作原理是在类被加载时对其进行重写，使其更适合于重载。</p>
<h4 id="821-记录条件评估的变化"><a class="header" href="#821-记录条件评估的变化">8.2.1. 记录条件评估的变化</a></h4>
<p>默认情况下，每次你的应用程序重新启动时，都会记录一份显示条件评估delta的报告。该报告显示了你的应用程序的自动配置的变化，因为你做了一些改变，如添加或删除Bean和设置配置属性。</p>
<p>要禁用报告的记录，请设置以下属性。</p>
<pre><code class="language-yaml">spring:
  devtools:
    restart:
      log-condition-evaluation-delta: false
</code></pre>
<h4 id="822-排除资源"><a class="header" href="#822-排除资源">8.2.2. 排除资源</a></h4>
<p>某些资源在被改变时不一定需要触发重启。例如，Thymeleaf模板可以被就地编辑。默认情况下，改变<code>/META-INF/maven</code>、<code>/META-INF/resources</code>、<code>/resources</code>、<code>/static</code>、<code>/public</code>或<code>/templates</code>中的资源不会触发重启，但会触发<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.livereload">live reload</a>。如果你想自定义这些排除项，你可以使用<code>spring.devtools.restart.exclude</code>属性。例如，为了只排除<code>/static</code>和<code>/public</code>，你可以设置以下属性。</p>
<pre><code class="language-yaml">spring:
  devtools:
    restart:
      exclude: &quot;static/**,public/**&quot;

</code></pre>
<blockquote>
<p>如果你想保留这些默认值，并添加额外的排除项，请使用<code>spring.devtools.restart.extra-exclude</code>属性来代替。</p>
</blockquote>
<h4 id="823-观察额外的路径"><a class="header" href="#823-观察额外的路径">8.2.3. 观察额外的路径</a></h4>
<p>当你对不在classpath上的文件进行修改时，你可能希望你的应用程序被重新启动或重新加载。要做到这一点，可以使用<code>spring.devtools.restart.extra-paths</code>属性来配置额外的路径来观察变化。你可以使用<code>spring.devtools.restart.exclude</code>属性<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart.excluding-resources">如前所述</a>来控制附加路径下的变化是触发完全重启还是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.livereload">实时重新加载</a>。</p>
<h4 id="824-禁用重新启动"><a class="header" href="#824-禁用重新启动">8.2.4. 禁用重新启动</a></h4>
<p>如果你不想使用重启功能，你可以通过使用<code>spring.devtools.restart.enabled</code>属性禁用它。在大多数情况下，你可以在你的<code>application.properties</code>中设置这个属性（这样做仍然会初始化重启类加载器，但它不会观察文件变化）。</p>
<p>如果你需要完全禁用重启支持（例如，因为它不能与特定的库一起工作），你需要在调用<code>SpringApplication.run(...)</code>之前将<code>spring.devtools.restart.enabled</code> <code>System</code>属性设置为<code>false</code>，如以下例子所示。</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        System.setProperty(&quot;spring.devtools.restart.enabled&quot;, &quot;false&quot;);
        SpringApplication.run(MyApplication.class, args);
    }

}
</code></pre>
<h4 id="825-使用trigger-file"><a class="header" href="#825-使用trigger-file">8.2.5. 使用Trigger File</a></h4>
<p>如果你使用一个持续编译修改过的文件的IDE工作，你可能更喜欢只在特定时间触发重启。要做到这一点，你可以使用一个 &quot;Trigger File&quot;，这是一个特殊的文件，当你想实际触发重启检查时，必须对它进行修改。</p>
<blockquote>
<p>对文件的任何更新都会触发检查，但只有在Devtools检测到它有事情要做时才会实际重新启动。</p>
</blockquote>
<p>要使用一个触发器文件，将<code>spring.devtools.restart.trigger-file</code>属性设置为触发器文件的名称（不包括任何路径）。触发器文件必须出现在你的classpath上的某个地方。</p>
<p>例如，如果你有一个结构如下的项目。</p>
<pre><code class="language-text">src
+- main
   +- resources
      +- .reloadtrigger
</code></pre>
<p>那么你的 <code>trigger-file</code> 属性将是。</p>
<pre><code class="language-yaml">spring:
  devtools:
    restart:
      trigger-file: &quot;.reloadtrigger&quot;
</code></pre>
<p>现在只有当<code>src/main/resources/.reloadtrigger</code>被更新时才会重新启动。</p>
<blockquote>
<p>你可能想把<code>spring.devtools.restart.trigger-file</code>设置为<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings">全局设置</a>，这样你的所有项目都会以同样的方式行事。</p>
</blockquote>
<p>一些IDE有一些功能，使你不需要手动更新你的触发器文件。<a href="https://spring.io/tools">Spring Tools for Eclipse</a>和<a href="https://www.jetbrains.com/idea/">IntelliJ IDEA (Ultimate Edition)</a>都有这种支持。对于Spring Tools，你可以使用控制台视图中的 &quot;reload &quot;按钮（只要你的<code>trigger-file</code>被命名为<code>.reloadtrigger</code>）。对于IntelliJ IDEA，你可以按照<a href="https://www.jetbrains.com/help/idea/spring-boot.html#application-update-policies">其文档中的说明</a>。</p>
<h4 id="826-自定义重启类加载器"><a class="header" href="#826-自定义重启类加载器">8.2.6. 自定义重启类加载器</a></h4>
<p>正如前面<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using-spring-boot-restart-vs-reload">重启与重载</a>一节中所描述的，重启功能是通过使用两个类加载器来实现。对于大多数应用程序来说，这种方法运行良好。然而，它有时会引起类加载问题。</p>
<p>默认情况下，你的IDE中任何打开的项目都是用 &quot;restart&quot; 类加载器加载的，而任何普通的<code>.jar</code>文件都是用 &quot;base&quot; 类加载器加载的。如果你在一个多模块项目上工作，而不是每个模块都被导入你的IDE，你可能需要定制一些东西。要做到这一点，你可以创建一个<code>META-INF/spring-devtools.properties</code>文件。</p>
<p><code>spring-devtools.properties</code>文件可以包含以<code>restart.exclude</code>和<code>restart.include</code>为前缀的属性。<code>include</code>元素是应该被拉到 &quot;restart&quot; 类加载器的项目，而<code>exclude</code>元素是应该被推到 &quot;base&quot; 类加载器的项目。该属性的值是一个应用于classpath的regex模式，如以下例子所示。</p>
<pre><code class="language-yaml">restart:
  exclude:
    companycommonlibs: &quot;/mycorp-common-[\\w\\d-\\.]+\\.jar&quot;
  include:
    projectcommon: &quot;/mycorp-myproj-[\\w\\d-\\.]+\\.jar&quot;

</code></pre>
<blockquote>
<p>所有的属性键必须是唯一的。只要一个属性以<code>restart.include.</code>或<code>restart.exclude.</code>开头，就被认为是。</p>
</blockquote>
<blockquote>
<p>所有来自classpath的<code>META-INF/spring-devtools.properties</code>都被加载。你可以在你的项目中打包文件，或者在项目所消耗的库中打包文件。</p>
</blockquote>
<h4 id="827-已知的限制"><a class="header" href="#827-已知的限制">8.2.7. 已知的限制</a></h4>
<p>重启功能对于那些通过使用标准的<code>ObjectInputStream</code>来反序列化的对象来说效果并不好。如果你需要反序列化数据，你可能需要使用Spring的<code>ConfigurableObjectInputStream</code>与<code>Thread.currentThread().getContextClassLoader()</code>相结合。</p>
<p>不幸的是，一些第三方库在进行反序列化时没有考虑上下文类加载器。如果你发现这样的问题，你需要向原作者请求修复。</p>
<h3 id="83-livereload"><a class="header" href="#83-livereload">8.3. LiveReload</a></h3>
<p><code>spring-boot-devtools</code>模块包括一个内嵌的LiveReload服务器，可以用来在资源发生变化时触发浏览器刷新。LiveReload浏览器扩展可以从<a href="http://livereload.com/extensions/">livereload.com</a>免费获得，适用于Chrome、Firefox和Safari。</p>
<p>如果你不想在应用程序运行时启动LiveReload服务器，你可以将<code>spring.devtools.livereload.enabled</code>属性设置为<code>false</code>。</p>
<p>你一次只能运行一个LiveReload服务器。在启动你的应用程序之前，确保没有其他LiveReload服务器正在运行。如果你从你的IDE启动多个应用程序，只有第一个有LiveReload支持。</p>
<blockquote>
<p>要在文件变化时触发LiveReload，必须启用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart">自动重新启动</a>。</p>
</blockquote>
<h3 id="84-全局设置"><a class="header" href="#84-全局设置">8.4. 全局设置</a></h3>
<p>你可以通过在<code>$HOME/.config/spring-boot</code>目录下添加以下任何文件来配置全局devtools设置。</p>
<ol>
<li>spring-boot-devtools.properties</li>
<li>spring-boot-devtools.yaml</li>
<li>spring-boot-devtools.yml</li>
</ol>
<p>添加到这些文件中的任何属性都适用于你机器上所有使用devtools的Spring Boot应用程序。例如，要将重启配置为始终使用<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart.triggerfile">触发文件</a>，你可以在<code>spring-boot-devtools</code>文件中添加以下属性。</p>
<pre><code class="language-yaml">spring:
  devtools:
    restart:
      trigger-file: &quot;.reloadtrigger&quot;
</code></pre>
<p>如果在<code>$HOME/.config/spring-boot</code>中找不到devtools的配置文件，则在<code>$HOME</code>目录的根部搜索是否有<code>.spring-boot-devtools.properties</code>文件。这允许你与那些不支持<code>$HOME/.config/spring-boot</code>位置的旧版Spring Boot的应用程序共享devtools全局配置。</p>
<p>devtools properties/yaml文件中不支持配置文件。</p>
<p>在<code>.spring-boot-devtools.properties</code>中激活的任何配置文件都不会影响<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.files.profile-specific">配置文件特定的配置文件</a>的加载。不支持YAML和属性文件中的特定配置文件（形式为<code>spring-boot-devtools-&lt;profile&gt;.properties</code>）和<code>spring.config.activated.on-profile</code>文件。</p>
<h4 id="841-配置-file-system-watcher"><a class="header" href="#841-配置-file-system-watcher">8.4.1. 配置 File System Watcher</a></h4>
<p><a href="https://github.com/spring-projects/spring-boot/tree/v2.5.3/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/filewatch/FileSystemWatcher.java">FileSystemWatcher</a>的工作方式是以一定的时间间隔轮询类的变化，然后等待一个预定义的安静期，以确保不再有变化。由于Spring Boot完全依赖IDE来编译并将文件复制到Spring Boot可以读取的位置，你可能会发现有时devtools重新启动应用程序时，某些变化并没有得到反映。如果你经常观察到这样的问题，可以尝试增加<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>参数到适合你开发环境的值。</p>
<pre><code class="language-yaml">spring:
  devtools:
    restart:
      poll-interval: &quot;2s&quot;
      quiet-period: &quot;1s&quot;

</code></pre>
<p>受监控的classpath目录现在每2秒轮询一次变化，并保持1秒的安静期以确保没有额外的类变化。</p>
<h3 id="85-远程应用"><a class="header" href="#85-远程应用">8.5. 远程应用</a></h3>
<p>Spring Boot的开发者工具并不局限于本地开发。你也可以在远程运行应用程序时使用一些功能。远程支持是可选的，因为启用它可能会有安全风险。只有在受信任的网络上运行时，或在用SSL保护时，才应启用它。如果这两个选项对你来说都不可用，你就不应该使用DevTools的远程支持。你不应该在生产部署中启用支持。</p>
<p>要启用它，你需要确保<code>devtools</code>包含在重新打包的档案中，如以下列表所示。</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>然后你需要设置<code>spring.devtools.remote.secret</code>属性。就像任何重要的密码或秘密一样，这个值应该是唯一的和强大的，以至于它不能被猜到或被暴力破解。</p>
<p>远程devtools支持由两部分组成：一个接受连接的服务器端端点和一个你在IDE中运行的客户端应用程序。当<code>spring.devtools.remote.secret</code>属性被设置时，服务器组件会自动启用。客户端组件必须手动启动。</p>
<h4 id="851-运行远程客户端应用程序"><a class="header" href="#851-运行远程客户端应用程序">8.5.1. 运行远程客户端应用程序</a></h4>
<p>远程客户端应用程序被设计成可以在你的IDE中运行。你需要运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>，其classpath与你所连接的远程项目相同。该应用程序的唯一必要参数是它所连接的远程URL。</p>
<p>例如，如果您使用的是 Eclipse 或 Spring Tools，并且您有一个名为 <code>my-app</code> 的项目，并已将其部署到 Cloud Foundry，您可以执行以下操作。</p>
<ul>
<li>从 <code>Run</code> 菜单中选择 <code>Run Configurations…​</code>。</li>
<li>创建一个新的<code>Java Application</code>&quot;启动配置&quot;。</li>
<li>浏览<code>my-app</code>项目。</li>
<li>使用<code>org.springframework.boot.devtools.RemoteSpringApplication</code>作为Main类。</li>
<li>在 <code>Program arguments</code> 中添加<code>https://myapp.cfapps.io</code>（或者你的远程URL）。</li>
</ul>
<p>一个正在运行的远程客户端可能类似于以下列表。</p>
<pre><code class="language-text">  .   ____          _                                              __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \
 \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )
  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /
 =========|_|==============|___/===================================/_/_/_/
 :: Spring Boot Remote :: 2.5.3

2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-project/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code)
2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy
2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.
2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)
</code></pre>
<p>因为远程客户端使用的是与真实应用程序相同的classpath，它可以直接读取应用程序的属性。<code>spring.devtools.remote.secret</code>属性就是这样被读取并传递给服务器进行认证。</p>
<p>始终建议使用<code>https://</code>作为连接协议，这样流量是加密的，密码也不会被截获。</p>
<p>如果你需要使用代理来访问远程应用程序，配置<code>spring.devtools.remote.proxy.host</code>和<code>spring.devtools.remote.proxy.port</code>属性。</p>
<h4 id="852-远程更新"><a class="header" href="#852-远程更新">8.5.2. 远程更新</a></h4>
<p>远程客户端以与<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart">本地重启</a>相同的方式监控你的应用程序classpath的变化。任何更新的资源都会被推送到远程应用程序，并（<em>如果需要</em>）触发重启。如果你在一个使用云服务的功能上迭代，而你在本地没有云服务，这可能会很有帮助。一般来说，远程更新和重启要比完全重建和部署周期快得多。</p>
<p>在一个较慢的开发环境中，可能会发生安静期不够的情况，类中的变化可能被分成几批。在第一批类的变化被上传后，服务器被重新启动。由于服务器正在重启，下一批不能被发送到应用程序。</p>
<p>这通常表现为在<code>RemoteSpringApplication</code>日志中出现警告，说未能上传一些类，并随之重试。但它也可能导致应用代码不一致，以及在第一批修改上传后无法重启。如果你不断观察到这样的问题，可以尝试增加<code>spring.devtools.restart.poll-interval</code>和<code>spring.devtools.restart.quiet-period</code>参数到适合你开发环境的值。参见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.globalsettings.configuring-file-system-watcher">配置文件系统观察器</a>一节，以配置这些属性。</p>
<p>文件只在远程客户端运行时被监控。如果你在启动远程客户端之前改变了一个文件，它不会被推送到远程服务器上。</p>
<h2 id="9-打包生产环境的应用"><a class="header" href="#9-打包生产环境的应用">9. 打包生产环境的应用</a></h2>
<p>Executable jars可以用于生产部署。由于它们是独立的，它们也非常适合于基于云的部署。</p>
<p>对于额外的 &quot;production ready&quot;功能，如health、auditing和metric REST或JMX end-points，考虑添加<code>spring-boot-actuator</code>。详情见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator">actuator.html</a>。</p>
<h2 id="10-接下来要读什么"><a class="header" href="#10-接下来要读什么">10. 接下来要读什么</a></h2>
<p>你现在应该明白如何使用Spring Boot以及应该遵循的一些最佳实践。现在你可以继续深入了解特定的<a href="/spring-boot/features.html">Spring Boot特性</a>，或者你可以跳过前面的内容，阅读Spring Boot的<a href="/spring-boot/actuator.html">生产就绪</a>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../spring-boot/upgrading.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../spring-boot/features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../spring-boot/upgrading.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../spring-boot/features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
                <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
                <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
